package com.android.build.gradle.integration.component;

import static com.android.build.gradle.integration.common.truth.TruthHelper.assertThat;

import com.android.build.gradle.integration.common.fixture.GradleTestProject;
import com.android.build.gradle.integration.common.fixture.app.EmptyAndroidTestApp;
import com.android.build.gradle.integration.common.utils.TestFileUtils;
import com.android.build.gradle.ndk.internal.NativeCompilerArgsUtil;
import com.android.builder.model.NativeAndroidProject;
import com.android.builder.model.NativeArtifact;
import com.android.builder.model.NativeFolder;
import com.android.builder.model.NativeSettings;
import com.android.utils.FileUtils;
import com.android.utils.StringHelper;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.stream.Collectors;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

/** Test NativeAndroidProject model generated by StandaloneNdkPlugin. */
public class StandaloneNdkModelTest {

    @Rule
    public GradleTestProject project =
            GradleTestProject.builder()
                    .fromTestApp(new EmptyAndroidTestApp())
                    .useExperimentalGradleVersion(true)
                    .create();

    private final Set<String> ABIS =
            ImmutableSet.of(
                    "armeabi", "armeabi-v7a", "arm64-v8a", "x86", "x86_64", "mips", "mips64");

    @Before
    public void setUp() throws IOException {
        FileUtils.createFile(project.file("src/main/jni/empty.c"), "");
        FileUtils.createFile(project.file("src/main/headers/empty.h"), "");
    }

    @Test
    public void checkSimpleModel() throws IOException, InterruptedException {
        TestFileUtils.appendToFile(
                project.getBuildFile(),
                "\n"
                        + "apply plugin: \"com.android.model.native\"\n"
                        + "\n"
                        + "model {\n"
                        + "    android {\n"
                        + "        compileSdkVersion "
                        + GradleTestProject.DEFAULT_COMPILE_SDK_VERSION
                        + "\n"
                        + "        ndk {\n"
                        + "            moduleName \"hello-jni\"\n"
                        + "        }\n"
                        + "        sources {\n"
                        + "            main {\n"
                        + "                jni {\n"
                        + "                    exportedHeaders.srcDir(\"src/main/headers\")\n"
                        + "                }\n"
                        + "            }\n"
                        + "        }\n"
                        + "    }\n"
                        + "}\n");
        NativeAndroidProject model =
                project.executeAndReturnModel(NativeAndroidProject.class, "clean", "assemble");
        assertThat(model.getBuildFiles()).isEmpty();
        checkModel(model, ImmutableSet.of("debug", "release"), ImmutableSet.of());
    }

    @Test
    public void checkMultiflavorModel() throws IOException, InterruptedException {
        TestFileUtils.appendToFile(
                project.getBuildFile(),
                "\n"
                        + "apply plugin: \"com.android.model.native\"\n"
                        + "\n"
                        + "model {\n"
                        + "    android {\n"
                        + "        compileSdkVersion "
                        + GradleTestProject.DEFAULT_COMPILE_SDK_VERSION
                        + "\n"
                        + "        ndk {\n"
                        + "            moduleName \"hello-jni\"\n"
                        + "        }\n"
                        + "        productFlavors {\n"
                        + "            create(\"free\") {\n"
                        + "                dimension \"pricing\"\n"
                        + "            }\n"
                        + "            create(\"paid\") {\n"
                        + "                dimension \"pricing\"\n"
                        + "            }\n"
                        + "            create(\"beta\") {\n"
                        + "                dimension \"releaseType\"\n"
                        + "            }\n"
                        + "            create(\"normal\") {\n"
                        + "                dimension \"releaseType\"\n"
                        + "            }\n"
                        + "        }\n"
                        + "    }\n"
                        + "}\n");
        NativeAndroidProject model =
                project.executeAndReturnModel(NativeAndroidProject.class, "clean", "assemble");
        assertThat(model.getBuildFiles()).isEmpty();
        checkModel(
                model,
                ImmutableSet.of("debug", "release"),
                ImmutableSet.of("freeBeta", "freeNormal", "paidBeta", "paidNormal"));
    }

    @Test
    public void checkModelWithVariants() throws IOException, InterruptedException {
        TestFileUtils.appendToFile(
                project.getBuildFile(),
                "\n"
                        + "apply plugin: \"com.android.model.native\"\n"
                        + "\n"
                        + "model {\n"
                        + "    android {\n"
                        + "        compileSdkVersion "
                        + GradleTestProject.DEFAULT_COMPILE_SDK_VERSION
                        + "\n"
                        + "        ndk {\n"
                        + "            moduleName \"hello-jni\"\n"
                        + "        }\n"
                        + "        buildTypes {\n"
                        + "            debug {\n"
                        + "                ndk {\n"
                        + "                    CFlags.add(\"-DDEBUG_C\")\n"
                        + "                    cppFlags.add(\"-DDEBUG_CPP\")\n"
                        + "                }\n"
                        + "            }\n"
                        + "            release {\n"
                        + "                ndk {\n"
                        + "                    CFlags.add(\"-DRELEASE_C\")\n"
                        + "                    cppFlags.add(\"-DRELEASE_CPP\")\n"
                        + "                }\n"
                        + "            }\n"
                        + "            create(\"optimized\") {\n"
                        + "                ndk {\n"
                        + "                    CFlags.add(\"-DOPTIMIZED_C\")\n"
                        + "                    cppFlags.add(\"-DOPTIMIZED_CPP\")\n"
                        + "                }\n"
                        + "            }\n"
                        + "        }\n"
                        + "        productFlavors {\n"
                        + "            create(\"free\") {\n"
                        + "                ndk {\n"
                        + "                    CFlags.add(\"-DFREE_C\")\n"
                        + "                    cppFlags.add(\"-DFREE_CPP\")\n"
                        + "                }\n"
                        + "            }\n"
                        + "            create(\"premium\") {\n"
                        + "                ndk {\n"
                        + "                    CFlags.add(\"-DPREMIUM_C\")\n"
                        + "                    cppFlags.add(\"-DPREMIUM_CPP\")\n"
                        + "                }\n"
                        + "            }\n"
                        + "        }\n"
                        + "        sources {\n"
                        + "            main {\n"
                        + "                jni {\n"
                        + "                    exportedHeaders.srcDir(\"src/main/headers\")\n"
                        + "                }\n"
                        + "            }\n"
                        + "        }\n"
                        + "    }\n"
                        + "}\n");
        NativeAndroidProject model =
                project.executeAndReturnModel(NativeAndroidProject.class, "clean", "assemble");
        assertThat(model.getBuildFiles()).isEmpty();
        checkModel(
                model,
                ImmutableSet.of("debug", "release", "optimized"),
                ImmutableSet.of("free", "premium"));

        // Check all setting contains the dimension specific flags.
        List<String> allDimensions =
                new ArrayList<String>(
                        Arrays.asList("debug", "release", "optimized", "free", "premium"));
        for (NativeArtifact artifact : model.getArtifacts()) {
            for (NativeFolder folder : artifact.getSourceFolders()) {
                final String cSettingName = folder.getPerLanguageSettings().get("c");
                NativeSettings cSettings =
                        model.getSettings()
                                .stream()
                                .filter(i -> i.getName().equals(cSettingName))
                                .findAny()
                                .orElse(null);
                assertThat(cSettings).isNotNull();

                final String cppSettingName = folder.getPerLanguageSettings().get("c++");
                NativeSettings cppSettings =
                        model.getSettings()
                                .stream()
                                .filter(i -> i.getName().equals(cppSettingName))
                                .findAny()
                                .orElse(null);
                assertThat(cppSettings).isNotNull();

                for (String dimension : allDimensions) {
                    String expectedCFlag = "-D" + dimension.toUpperCase(Locale.US) + "_C";
                    String expectedCppFlag = "-D" + dimension.toUpperCase(Locale.US) + "_CPP";

                    if (artifact.getName().toLowerCase(Locale.US).contains(dimension)) {
                        assertThat(cSettings.getCompilerFlags()).contains(expectedCFlag);
                        assertThat(cppSettings.getCompilerFlags()).contains(expectedCppFlag);
                    } else {
                        assertThat(cSettings.getCompilerFlags()).doesNotContain(expectedCFlag);
                        assertThat(cppSettings.getCompilerFlags()).doesNotContain(expectedCppFlag);
                    }

                }

                assertThat(cSettings.getCompilerFlags())
                        .contains(
                                NativeCompilerArgsUtil.transform(
                                        "-I" + project.file("src/main/headers")));
                assertThat(cppSettings.getCompilerFlags())
                        .contains(
                                NativeCompilerArgsUtil.transform(
                                        "-I" + project.file("src/main/headers")));
            }

        }

    }

    private void checkModel(
            NativeAndroidProject model, Set<String> buildTypes, Set<String> productFlavors) {
        Collection<NativeArtifact> artifacts = model.getArtifacts();

        assertThat(model.getFileExtensions()).containsEntry("c", "c");
        assertThat(model.getFileExtensions()).containsEntry("C", "c++");
        assertThat(model.getFileExtensions()).containsEntry("CPP", "c++");
        assertThat(model.getFileExtensions()).containsEntry("c++", "c++");
        assertThat(model.getFileExtensions()).containsEntry("cc", "c++");
        assertThat(model.getFileExtensions()).containsEntry("cp", "c++");
        assertThat(model.getFileExtensions()).containsEntry("cpp", "c++");
        assertThat(model.getFileExtensions()).containsEntry("cxx", "c++");

        productFlavors = productFlavors.isEmpty() ? ImmutableSet.of("") : productFlavors;
        for (List<String> combo : Sets.cartesianProduct(buildTypes, productFlavors, ABIS)) {
            final String buildType = combo.get(0);
            final String flavor = combo.get(1);
            final String abi = combo.get(2);
            String variant =
                    flavor.isEmpty() ? buildType : flavor + StringHelper.capitalize(buildType);
            String name = variant + "-" + abi;

            NativeArtifact artifact =
                    artifacts
                            .stream()
                            .filter(a -> a.getName().equals(name))
                            .findFirst()
                            .orElseThrow(
                                    () -> new AssertionError(name + " native artifact not found."));

            assertThat(artifact.getGroupName()).isEqualTo(variant);
            assertThat(artifact.getAssembleTaskName())
                    .isEqualTo(
                            "hello-jni"
                                    + (abi.isEmpty() ? "" : StringHelper.capitalize(abi))
                                    + (buildType.isEmpty()
                                            ? ""
                                            : StringHelper.capitalize(buildType))
                                    + (flavor.isEmpty() ? "" : StringHelper.capitalize(flavor))
                                    + "SharedLibrary");
            assertThat(artifact.getOutputFile()).hasName("libhello-jni.so");
            assertThat(artifact.getSourceFiles()).isEmpty();
            assertThat(artifact.getToolChain()).endsWith(abi);

            List<File> expectedSrc =
                    ImmutableList.of("main", buildType, flavor, variant)
                            .stream()
                            .filter(s -> !s.isEmpty())
                            .distinct()
                            .map(i -> project.file("src/" + i + "/jni"))
                            .collect(Collectors.toList());

            assertThat(
                            artifact.getSourceFolders()
                                    .stream()
                                    .map(NativeFolder::getFolderPath)
                                    .collect(Collectors.toList()))
                    .containsAllIn(expectedSrc);
            assertThat(artifact.getExportedHeaders())
                    .containsExactly(project.file("src/main/headers"));
        }

    }
}
