package com.example.bytecode.plugins;

import com.android.build.gradle.*;
import com.android.build.gradle.api.BaseVariant;
import java.io.File;
import org.gradle.api.DomainObjectSet;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.file.ConfigurableFileCollection;

/**
 * Simple plugin that register a bytecode generating task
 *
 * <p>It loops on all the variants (including the test ones), and for each variant it registers a
 * new task. The bytecode generated by the task depends on the type of the variant (app vs lib vs
 * test)
 */
public class CompilerPlugin implements Plugin<Project> {

    private Project project;
    private File appJar;
    private File libJar;
    private File testJar;

    @Override
    public void apply(Project project) {
        this.project = project;

        computeJarLocations();

        // process existing plugins
        project.getPlugins().forEach(this::handlePlugin);
        // process future plugins
        project.getPlugins().whenPluginAdded(this::handlePlugin);
    }

    private void handlePlugin(Plugin plugin) {
        final Class<? extends Plugin> pluginClass = plugin.getClass();

        TestedExtension testedExtension = null;

        if (pluginClass.equals(AppPlugin.class)) {
            AppExtension extension = (AppExtension) project.getExtensions().getByName("android");
            processVariants(extension.getApplicationVariants(), appJar);

            testedExtension = extension;
        } else if (pluginClass.equals(LibraryPlugin.class)) {
            LibraryExtension extension =
                    (LibraryExtension) project.getExtensions().getByName("android");
            processVariants(extension.getLibraryVariants(), libJar);

            testedExtension = extension;
        } else if (pluginClass.equals(TestPlugin.class)) {
            TestExtension extension = (TestExtension) project.getExtensions().getByName("android");
            processVariants(extension.getApplicationVariants(), testJar);
            // no test here.
        }

        if (testedExtension != null) {
            processVariants(testedExtension.getTestVariants(), testJar);
            processVariants(testedExtension.getUnitTestVariants(), testJar);
        }
    }

    private void computeJarLocations() {
        File rootDir = project.getRootProject().getProjectDir();
        appJar = new File(rootDir, "app.jar");
        libJar = new File(rootDir, "lib.jar");
        testJar = new File(rootDir, "test.jar");
    }

    private <T extends BaseVariant> void processVariants(
            DomainObjectSet<T> variants, File sourceJar) {
        variants.all(
                variant -> {
                    // figure out the output.
                    File outputDir =
                            project.file(
                                    project.getBuildDir()
                                            + "/generated/bytecode/"
                                            + variant.getDirName());

                    // create the file collection that contains the result. We'll add the task
                    // dependency later when we have it
                    ConfigurableFileCollection fc = project.files(outputDir);

                    // and register it with the variant, getting the key in return
                    Object key = variant.registerGeneratedBytecode(fc);

                    // create the task, querying the classpath with the provided key.
                    BytecodeGeneratingTask t =
                            project.getTasks()
                                    .create(
                                            "generateBytecodeFor" + variant.getName(),
                                            BytecodeGeneratingTask.class,
                                            task -> {
                                                task.setSourceJar(sourceJar);
                                                task.setOutputDir(outputDir);
                                                task.setClasspath(variant.getCompileClasspath(key));
                                            });

                    // add the task dependency
                    fc.builtBy(t);

                    // make the task run after the variant's prebuild task
                    t.dependsOn(variant.getPreBuild());
                });
    }
}
