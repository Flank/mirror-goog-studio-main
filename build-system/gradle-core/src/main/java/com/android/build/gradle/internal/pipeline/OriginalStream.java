/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.build.gradle.internal.pipeline;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

import com.android.annotations.NonNull;
import com.android.annotations.concurrency.Immutable;
import com.android.build.api.transform.DirectoryInput;
import com.android.build.api.transform.JarInput;
import com.android.build.api.transform.QualifiedContent;
import com.android.build.api.transform.QualifiedContent.ContentType;
import com.android.build.api.transform.QualifiedContent.Scope;
import com.android.build.api.transform.Status;
import com.android.build.api.transform.TransformInput;
import com.google.common.base.Charsets;
import com.google.common.base.MoreObjects;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.google.common.hash.Hashing;
import groovy.lang.Closure;
import java.io.File;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import org.gradle.api.Project;
import org.gradle.api.file.ConfigurableFileCollection;
import org.gradle.api.file.FileCollection;

/**
 * Version of TransformStream handling input that is not generated by transforms.
 */
@Immutable
public class OriginalStream extends TransformStream {

    public static Builder builder(Project project) {
        return new Builder(project);
    }

    public static final class Builder {
        private final Project project;
        private Set<ContentType> contentTypes = Sets.newHashSet();
        private FileCollection fileCollection;
        private QualifiedContent.ScopeType scope;
        private Supplier<Collection<File>> jarFiles;
        private Supplier<Collection<File>> folders;
        private ImmutableList<? extends Object> dependencies;

        public Builder(Project project) {
            this.project = project;
        }

        public OriginalStream build() {
            checkNotNull(scope);
            checkState(!contentTypes.isEmpty());

            if (fileCollection == null) {
                // create a file collection with the files and the dependencies.
                fileCollection = project.files(
                        (Callable<Object>) () -> {
                            if (jarFiles != null && folders != null) {
                                return ImmutableList.of(jarFiles.get(), folders.get());
                            }
                            if (jarFiles != null) {
                                return jarFiles.get();
                            }

                            if (folders != null) {
                                return folders.get();
                            }

                            return ImmutableList.of();
                        },
                        new Closure(project) {
                            public Object doCall(ConfigurableFileCollection fileCollection) {
                                if (dependencies != null) {
                                    fileCollection.builtBy(dependencies.toArray());
                                }
                                return null;
                            }
                        });
            }

            return new OriginalStream(
                    ImmutableSet.copyOf(contentTypes), scope, fileCollection);
        }

        public Builder addContentTypes(@NonNull Set<ContentType> types) {
            this.contentTypes.addAll(types);
            return this;
        }

        public Builder addContentTypes(@NonNull ContentType... types) {
            this.contentTypes.addAll(Arrays.asList(types));
            return this;
        }

        public Builder addContentType(@NonNull ContentType type) {
            this.contentTypes.add(type);
            return this;
        }

        public Builder addScope(@NonNull QualifiedContent.ScopeType scope) {
            this.scope = scope;
            return this;
        }

        public Builder setJar(@NonNull final File jarFile) {
            Preconditions.checkState(fileCollection == null, "Cannot set both file collection and jars/folders");
            this.jarFiles = () -> ImmutableList.of(jarFile);
            return this;
        }

        public Builder setJars(@NonNull Supplier<Collection<File>> jarSupplier) {
            Preconditions.checkState(fileCollection == null, "Cannot set both file collection and jars/folders");
            this.jarFiles = jarSupplier;
            return this;
        }

        public Builder setFolder(@NonNull final File folder) {
            Preconditions.checkState(fileCollection == null, "Cannot set both file collection and jars/folders");
            this.folders = () -> ImmutableList.of(folder);
            return this;
        }

        public Builder setFolders(@NonNull Supplier<Collection<File>> folderSupplier) {
            Preconditions.checkState(fileCollection == null, "Cannot set both file collection and jars/folders");
            this.folders = folderSupplier;
            return this;
        }

        public Builder setDependencies(@NonNull List<? extends Object> dependencies) {
            Preconditions.checkState(fileCollection == null, "Cannot set both file collection and jars/folders");
            this.dependencies = ImmutableList.copyOf(dependencies);
            return this;
        }

        public Builder setDependency(@NonNull Object dependency) {
            Preconditions.checkState(fileCollection == null, "Cannot set both file collection and jars/folders");
            this.dependencies = ImmutableList.of(dependency);
            return this;
        }

        public Builder setFileCollection(@NonNull FileCollection fileCollection) {
            Preconditions.checkState(jarFiles == null && folders == null && dependencies == null,
                    "Cannot set both file collection and jars/folders");
            this.fileCollection = fileCollection;
            return this;
        }
    }

    private OriginalStream(
            @NonNull Set<ContentType> contentTypes,
            @NonNull QualifiedContent.ScopeType scope,
            @NonNull FileCollection files) {
        super(contentTypes, ImmutableSet.of(scope), files);
    }

    private static class OriginalTransformInput extends IncrementalTransformInput {

        @Override
        protected boolean checkRemovedFolder(
                @NonNull Set<? super Scope> transformScopes,
                @NonNull Set<ContentType> transformInputTypes,
                @NonNull File file,
                @NonNull List<String> fileSegments) {
            // we can never detect if a random file was removed from this input.
            return false;
        }

        @Override
        boolean checkRemovedJarFile(
                @NonNull Set<? super Scope> transformScopes,
                @NonNull Set<ContentType> transformInputTypes,
                @NonNull File file,
                @NonNull List<String> fileSegments) {
            // we can never detect if a jar was removed from this input.
            return false;
        }
    }

    @NonNull
    @Override
    TransformInput asNonIncrementalInput() {
        Set<ContentType> contentTypes = getContentTypes();
        Set<? super Scope> scopes = getScopes();

        Set<File> files = getFiles().getFiles();

        List<JarInput> jarInputs = files.stream()
                .filter(File::isFile)
                .map(file -> new ImmutableJarInput(
                        getUniqueInputName(file),
                        file,
                        Status.NOTCHANGED,
                        contentTypes,
                        scopes))
                .collect(Collectors.toList());

        List<DirectoryInput> directoryInputs = files.stream()
                .filter(File::isDirectory)
                .map(file -> new ImmutableDirectoryInput(
                        getUniqueInputName(file),
                        file,
                        contentTypes,
                        scopes))
                .collect(Collectors.toList());

        return new ImmutableTransformInput(jarInputs, directoryInputs, null);
    }

    @NonNull
    @Override
    IncrementalTransformInput asIncrementalInput() {
        IncrementalTransformInput input = new OriginalTransformInput();

        Set<ContentType> contentTypes = getContentTypes();
        Set<? super Scope> scopes = getScopes();

        getFiles().getFiles().forEach(file -> {
            if (file.isDirectory()) {
                input.addFolderInput(new MutableDirectoryInput(
                        getUniqueInputName(file),
                        file,
                        contentTypes,
                        scopes));
            } else if (file.isFile()) {
                input.addJarInput(new QualifiedContentImpl(
                        getUniqueInputName(file),
                        file,
                        contentTypes,
                        scopes));
            }
        });

        return input;
    }

    @NonNull
    private static String getUniqueInputName(@NonNull File file) {
        return Hashing.sha1().hashString(file.getPath(), Charsets.UTF_16LE).toString();
    }

    @Override
    TransformStream makeRestrictedCopy(
            @NonNull Set<ContentType> types,
            @NonNull Set<? super Scope> scopes) {
        if (!scopes.equals(getScopes())) {
            // since the content itself (jars and folders) don't have they own notion of scopes
            // we cannot do a restricted stream. However, since this stream is always created
            // with a single stream, this shouldn't happen.
            throw new UnsupportedOperationException("Cannot do a scope-restricted OriginalStream");
        }
        return new OriginalStream(
                types,
                (QualifiedContent.ScopeType) Iterables.getOnlyElement(scopes),
                getFiles());
    }

    @Override
    public String toString() {
        return MoreObjects.toStringHelper(this)
                .add("scopes", getScopes())
                .add("contentTypes", getContentTypes())
                .add("fileCollection", getFiles())
                .toString();
    }
}
