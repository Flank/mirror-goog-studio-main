/*
 * Copyright (C) 2018 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.build.gradle.internal.res.namespaced

import com.android.annotations.VisibleForTesting
import com.android.build.gradle.internal.publishing.AndroidArtifacts.ArtifactScope
import com.android.build.gradle.internal.publishing.AndroidArtifacts.ArtifactType
import com.android.build.gradle.internal.publishing.AndroidArtifacts.ConsumedConfigType
import com.android.build.gradle.internal.scope.TaskConfigAction
import com.android.build.gradle.internal.scope.VariantScope
import com.android.build.gradle.internal.tasks.AndroidBuilderTask
import com.android.ide.common.symbols.SymbolIo
import com.android.ide.common.symbols.SymbolTable
import com.android.utils.FileUtils
import com.google.common.collect.ImmutableList
import com.google.common.collect.ImmutableMap
import org.gradle.api.artifacts.ArtifactCollection
import org.gradle.api.artifacts.ResolvableDependencies
import org.gradle.api.artifacts.component.ProjectComponentIdentifier
import org.gradle.api.file.FileCollection
import org.gradle.api.logging.Logger
import org.gradle.api.tasks.InputFiles
import org.gradle.api.tasks.OutputDirectory
import org.gradle.api.tasks.TaskAction
import java.io.File

/**
 * Rewrites the classes.jar files of the module's dependencies to be fully resource namespaced. It
 * does not rewrite the references inside the resources in the libraries, only in the bytecode.
 */
open class AutoNamespaceDependenciesTask : AndroidBuilderTask() {

    lateinit var rFiles: ArtifactCollection private set
    lateinit var jarFiles: ArtifactCollection private set
    lateinit var dependencies: ResolvableDependencies private set

    @InputFiles fun getRFiles(): FileCollection = rFiles.artifactFiles
    @InputFiles fun getClassesJarFiles(): FileCollection = jarFiles.artifactFiles
    @InputFiles fun getDependenciesFiles(): FileCollection = dependencies.files

    @VisibleForTesting var log: Logger? = null
    private var symbolTablesCache: HashMap<File, SymbolTable> = HashMap()

    @get:OutputDirectory lateinit var outputRewrittenClasses: File private set

    @TaskAction
    fun taskAction() = namespaceDependencies()

    @VisibleForTesting
    fun namespaceDependencies(
        dependencies: ResolvableDependencies = this.dependencies,
        rFiles: ArtifactCollection = this.rFiles,
        jarFiles: ArtifactCollection = this.jarFiles,
        outputDirectory: File = this.outputRewrittenClasses
    ) {
        // First, create a graph based on the ResolvableDependencies and the Artifact Collections.
        // Each node in the DependenciesGraph is an external dependency and is either a full AAR or
        // a JAR dependency.
        // Each node will hold the information about its dependencies. Additionally, nodes
        // representing AARs will also contain the paths to the corresponding R-def.txt file and
        // their classes.jar file; nodes representing JAR dependencies will have neither.
        val graph = DependenciesGraph.create(
                dependencies,
                ImmutableMap.of(
                        ArtifactType.DEFINED_ONLY_SYMBOL_LIST, rFiles.toMap(),
                        ArtifactType.NON_NAMESPACED_CLASSES, jarFiles.toMap()
                )
        )

        // The rewriting works per node, since for rewriting a library the only files from its
        // dependencies we need are their R-def.txt files, which were already generated by the
        // [LibraryDefinedSymbolTableTransform].
        // TODO: do this in parallel
        for (dependency in graph.allNodes) {
            namespaceDependency(dependency, outputDirectory)
        }
        symbolTablesCache.clear()
    }

    private fun namespaceDependency(
        dependency: DependenciesGraph.Node,
        outputDirectory: File
    ) {
        val input = dependency.getFile(ArtifactType.NON_NAMESPACED_CLASSES)
        // Only convert external nodes and non-namespaced libraries. Already namespaced libraries
        // and JAR files can be present in the graph, but they will not contain the
        // NON_NAMESPACED_CLASSES artifacts. Only try to rewrite non-namespaced libraries' classes.
        if (dependency.id !is ProjectComponentIdentifier && input != null) {
            val out = File(
                    outputDirectory,
                    "namespaced-${dependency.id.displayName}-${input.name}"
            )

            // The rewriting algorithm uses ordered symbol tables, with this library's table at the
            // top of the list. It looks up resources starting from the top of the list, trying to
            // find where the references resource was defined (or overridden), closest to the root
            // (this node) in the dependency graph.
            val symbolTables = getSymbolTables(dependency)
            NamespaceRewriter(symbolTables, log ?: logger).rewriteJar(input, out)
        }
    }

    private fun getSymbolTables(node: DependenciesGraph.Node): ImmutableList<SymbolTable> {
        synchronized(symbolTablesCache) {
            val builder = ImmutableList.builder<SymbolTable>()

            // Reading the R files and building symbol tables is very costly, remember them in the
            // cache when reading for the first time, then just fetch the already build table.
            for (rFile in node.getTransitiveFiles(ArtifactType.DEFINED_ONLY_SYMBOL_LIST)) {
                if (!symbolTablesCache.contains(rFile)) {
                    val table = SymbolIo.readRDef(rFile.toPath())
                    symbolTablesCache.put(rFile, table)
                }
                builder.add(symbolTablesCache[rFile]!!)
            }
            return builder.build()
        }
    }

    private fun ArtifactCollection.toMap(): ImmutableMap<String, File> =
        ImmutableMap.builder<String, File>().apply {
            for (artifact in artifacts) {
                put(artifact.id.componentIdentifier.displayName, artifact.file)
            }
        }.build()

    class ConfigAction(private val variantScope: VariantScope) :
            TaskConfigAction<AutoNamespaceDependenciesTask> {

        override fun getName(): String = variantScope.getTaskName("AutoNamespace", "Dependencies")

        override fun getType(): Class<AutoNamespaceDependenciesTask>
                = AutoNamespaceDependenciesTask::class.java

        override fun execute(task: AutoNamespaceDependenciesTask) {

            task.rFiles = variantScope.getArtifactCollection(
                    ConsumedConfigType.RUNTIME_CLASSPATH,
                    ArtifactScope.EXTERNAL,
                    ArtifactType.DEFINED_ONLY_SYMBOL_LIST
            )

            task.jarFiles = variantScope.getArtifactCollection(
                    ConsumedConfigType.RUNTIME_CLASSPATH,
                    ArtifactScope.EXTERNAL,
                    ArtifactType.NON_NAMESPACED_CLASSES
            )

            task.outputRewrittenClasses = FileUtils.join(
                    variantScope.globalScope.intermediatesDir, "namespaced-classes-jars",
                    variantScope.variantConfiguration.dirName
            )

            task.dependencies =
                    variantScope.variantData.variantDependency.runtimeClasspath.incoming
        }
    }
}