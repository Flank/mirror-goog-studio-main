apply plugin: 'com.android.tools.java-library'
apply plugin: 'com.android.tools.kotlin'
apply plugin: 'com.android.tools.publish'
apply plugin: 'com.android.tools.metalava'

configurations {
    compileOnlyForJavadoc {
        extendsFrom(configurations.compileOnly)
    }
}

dependencies {
    implementation project(':base:builder-test-api')
    implementation libs.guava
    implementation libs.kotlin_stdlib
    api libs.asm

    compileOnly libs.com.android.tools.annotations
    compileOnly gradleApi()
    compileOnly project(':base:builder-model') // Only present for legacy reasons.

    metalavaTestImplementation libs.com.android.tools.testutils
    metalavaTestImplementation libs.guava
    metalavaTestImplementation libs.junit
    metalavaTestImplementation libs.kotlin_test

    testImplementation libs.junit
    testImplementation libs.kotlin_test
    testImplementation libs.com.android.tools.testutils
    testImplementation gradleApi()
    testImplementation project(':base:builder-model')
    testImplementation libs.com.android.tools.annotations
    testImplementation libs.com.android.tools.common
    testImplementation libs.mockito_core
    testImplementation libs.equalsverifier
}

javadoc {
  classpath += configurations.compileOnlyForJavadoc
}

task javadocZip(type: Zip) {
  dependsOn javadoc
  from javadoc.destinationDir
  archiveBaseName.set('javadoc')
}

group = 'com.android.tools.build'
archivesBaseName = 'gradle-api'
version = rootProject.ext.buildVersion

project.ext.pomName = 'Android Gradle API'
project.ext.pomDesc = 'APIs to customize Android Gradle Builds'

import com.android.tools.internal.dackka.DackkaTask


abstract class WriteVersionFile extends DefaultTask {
    @Input
    abstract Property<String> getBuildVersion()

    @OutputDirectory
    abstract DirectoryProperty getOutputDirectory()

    @TaskAction
    def writeFile() {
        def outputDir = outputDirectory.get().asFile
        outputDir.deleteDir()
        outputDir.mkdir()
        def versionFile = new File(outputDir, "version.properties")

        def docsVersion = buildVersion.get().substring(0, buildVersion.get().lastIndexOf("."))
        def properties = new Properties()
        properties.put("androidGradlePluginVersion", buildVersion.get())
        properties.put("docsVersion", docsVersion)
        versionFile.withWriter {properties.store(it, null) }
    }
}

def writeVersionFileProvider = tasks.register("writeDocsVersionFile", WriteVersionFile) {
    it.getBuildVersion().set(provider { rootProject.ext.buildVersion })
    it.getOutputDirectory().set(project.layout.buildDirectory.dir("dokkaVersion"))
}

String devsitePrefix = "tools/gradle-api/" +  version.substring(0, version.lastIndexOf("."))

def dackkaTask = tasks.register("dackkaDocs", DackkaTask) {
    devsiteTenant.set(devsitePrefix)
    destinationDirectory.set(project.layout.buildDirectory.dir("dackka"))
    dackkaClasspath.from(rootProject.file("../prebuilts/tools/common/dackka/dackka-0.0.19.jar"))
    dependenciesClasspath.from(configurations.compileClasspath)
    sourcesDir.set(sourceSets.main.java.sourceDirectories.singleFile)
    packageListsDirectory.set(rootProject.file("../prebuilts/tools/common/dackka/package-lists"))

}

task dackkaZip(type: Zip) {
    // The consumption script expects the reference/tools/gradle-api/<version>/ prefix to be removed
    from(dackkaTask.flatMap{ it.destinationDirectory.dir('reference/' + devsitePrefix) })
    from writeVersionFileProvider.map { it.outputDirectory }
    destinationDirectory.set(rootProject.ext.androidHostDist)
    archiveFileName = "documentation.zip"
}

def updateDeprecatedApi = tasks.register('updateDeprecatedApi', JavaExec) {
    classpath(sourceSets['test'].output.classesDirs, sourceSets['test'].runtimeClasspath)
    mainClass = 'com.android.build.api.DeprecatedApiUpdater'
}

def updateApi = tasks.register('updateApi') {
    dependsOn('updateMetalavaApi')
    dependsOn(updateDeprecatedApi)
}
