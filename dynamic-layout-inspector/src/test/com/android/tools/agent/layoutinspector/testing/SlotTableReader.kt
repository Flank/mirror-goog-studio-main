/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.tools.agent.layoutinspector.testing

import android.view.View
import androidx.compose.SlotTable
import androidx.ui.core.R
import androidx.ui.core.ModifierInfo
import androidx.ui.core.OwnedLayer
import androidx.ui.tooling.CallGroup
import androidx.ui.tooling.Group
import androidx.ui.unit.IntPx
import androidx.ui.unit.IntPxBounds
import org.mockito.Mockito

/**
 * Reader for a CSV file with a SlotTree
 *
 * Use this class to read a CSV files that emulates the SlotTree created with the tooling support
 * found in Compose. The result is loaded into the global variable: tables in Inspectable.kt.
 * The input format is the same as the output generated by ComposeTree while displaying a composable
 * in the layout inspector.
 */
class SlotTableReader(private val androidComposeView: View) : CsvReader(7) {
    private val slots = mutableListOf<Group>()
    private val roots = mutableListOf<Group>()

    override fun resetState() {
        slots.clear()
        roots.clear()
    }

    override fun storeState() {
        val slotTables = setOf(SlotTable(roots.toTypedArray()))
        Mockito.`when`(androidComposeView.getTag(Mockito.eq(R.id.inspection_slot_table_set)))
            .thenReturn(slotTables)
    }

    override fun parseColumns(columns: List<String>) {
        val indent = parseIndent(columns[0])
        val drawId = parseInt(columns[1])
        val position = parsePosition(columns[2])
        val left = parseInt(columns[3])
        val right = parseInt(columns[4])
        val top = parseInt(columns[5])
        val bottom = parseInt(columns[6])
        val bounds = toBounds(left, right, top, bottom)
        addNode(indent, drawId, position, bounds)
    }

    private fun parsePosition(position: String): String? {
        if (position == "null") {
            return null
        }
        return parseQuotedString(position)
    }

    private fun toBounds(left: Int, right: Int, top: Int, bottom: Int): IntPxBounds =
        IntPxBounds(IntPx(left), IntPx(top), IntPx(right), IntPx(bottom))

    private fun addNode(indent: Int, drawId: Int, position: String?, bounds: IntPxBounds) {
        val node = CallGroup(position, bounds, emptyList(), modifierInfo(drawId), mutableListOf())
        if (indent > slots.size) {
            error("Cannot parse line $lineNumber: The indent \"$indent\" is a jump up")
        }
        if (indent < slots.size) {
            slots.subList(indent, slots.size).clear()
        }
        if (slots.isEmpty()) {
            roots.add(node)
        }
        else {
            (slots.last().children as MutableList).add(node)
        }
        slots.add(node)
    }

    private fun modifierInfo(drawId: Int): List<ModifierInfo> {
        if (drawId == 0) {
            return emptyList()
        }
        return listOf(ModifierInfo(null, null, OwnedLayer(drawId.toLong())))
    }
}
