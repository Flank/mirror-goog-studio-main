apply plugin: 'java'
apply plugin: 'org.anarres.jarjar'
apply plugin: 'com.google.protobuf'

buildscript {
    dependencies {
        classpath 'org.anarres.jarjar:jarjar-gradle:1.0.0'
        classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.1'
    }
}

archivesBaseName = 'studio-profiler-grpc'
version = '1.0'// TODO: Pass in as an argument

ext {
    protobufVersion = '3.0.0'
    grpcVersion = '1.0.3'
    // We need to package in our own copy of netty dependencies, since Studio
    // can manually update its own netty library separately from us.
    // See also: https://mvnrepository.com/artifact/io.grpc/grpc-netty/1.0.3
    nettyVersion = '4.1.6.Final'
}

configurations {
    packaging
}

dependencies {
    packaging("com.google.protobuf:protobuf-java:$protobufVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-auth:$grpcVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-context:$grpcVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-core:$grpcVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-netty:$grpcVersion") {
        transitive false
    }
    packaging("io.netty:netty-handler-proxy:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-codec-http2:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-transport:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-codec-socks:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-codec-http:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-handler:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-buffer:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-resolver:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-codec:$nettyVersion") {
        transitive false
    }
    packaging("io.netty:netty-common:$nettyVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-okhttp:$grpcVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-protobuf:$grpcVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-protobuf-lite:$grpcVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-protobuf-nano:$grpcVersion") {
        transitive false
    }
    packaging("io.grpc:grpc-stub:$grpcVersion") {
        transitive false
    }
    compile "com.google.protobuf:protobuf-java:$protobufVersion"
    compile "io.grpc:grpc-all:$grpcVersion"
}

sourceSets {
    main {
        proto {
            srcDir '../proto'
        }
    }
}

protobuf {
    protoc {
        // The version of protoc must match protobuf-java. If you don't depend on
        // protobuf-java directly, you will be transitively depending on the
        // protobuf-java version that grpc depends on.
        artifact = "com.google.protobuf:protoc:$protobufVersion"
    }
    plugins {
        grpc {
            artifact = "io.grpc:protoc-gen-grpc-java:$grpcVersion"
        }
    }
    generateProtoTasks {
        // Iterate through all() configurations and run .plugins.
        // *. is just a shorthand for "for each item run this".
        all() *.plugins {
            grpc {}
        }
    }
}

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

jarjar.repackage('jarjarLibs') {
    destinationName = archivesBaseName + '-' + version + '-jarjar.jar'
    from configurations.packaging
    from files(sourceSets.main.output.classesDir)
    dependsOn sourceSets.main.output
    classRename 'com.google.protobuf.**', 'com.google.protobuf3jarjar.@1'
    classRename 'io.netty.**', 'io.nettyjarjar.@1'
}

artifacts {
    archives(jarjarLibs.destinationPath) {
        name 'ProfilerServerApi'
        type 'jar'
        builtBy jarjarLibs
    }

    archives sourcesJar
}

def runtime = "$rootDir/../../../out/studio/runtime/"
task copy(type: Copy, dependsOn: jarjarLibs) {
    from           jarjarLibs.outputs
    destinationDir file(runtime)
}
build.dependsOn copy
