/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.tools.binaries;

import com.android.tools.bazel.model.Package;
import com.android.tools.bazel.model.Workspace;
import com.android.tools.bazel.parser.ast.Argument;
import com.android.tools.bazel.parser.ast.CallExpression;
import com.android.tools.bazel.parser.ast.CallStatement;
import com.android.tools.bazel.parser.ast.DictExpression;
import com.android.tools.bazel.parser.ast.Expression;
import com.android.tools.bazel.parser.ast.ListExpression;
import com.android.tools.bazel.parser.ast.Statement;
import com.android.tools.bazel.parser.ast.Token;
import com.android.tools.maven.MavenRepository;
import com.android.tools.utils.WorkspaceUtils;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UncheckedIOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Stream;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import org.apache.maven.model.Model;
import org.eclipse.aether.artifact.Artifact;
import org.eclipse.aether.resolution.ArtifactDescriptorException;

/**
 * Binary that updates the maven repo BUILD file with a single java_import for
 * every {@code *.pom} file in it.
 */
public class JavaImportGenerator {

    static final String JAR_RULE_SUFFIX = "";
    static final String AAR_RULE_SUFFIX = "_aar";
    static final String APK_RULE_SUFFIX = "_apk";
    static final String POM_RULE_SUFFIX = "_pom";
    static final String EXE_RULE_SUFFIX = "_exe";
    private static final Set<String> SUPPORTED_EXTENSIONS = ImmutableSet.of("jar", "aar", "apk");
    private static final String GENERATED_WARNING =
            "# This BUILD file was generated by //tools/base/bazel:java_import_generator, please do not edit.";

    public static void main(String[] args) throws IOException, ArtifactDescriptorException {
        Path repoDirectory;

        if (args.length == 1) {
            repoDirectory = Paths.get(args[0]);
        } else {
            repoDirectory = WorkspaceUtils.findPrebuiltsRepository();
        }

        if (!Files.isDirectory(repoDirectory)) {
            usage();
        }
        Workspace workspace = new Workspace(WorkspaceUtils.findWorkspace().toFile());
        new JavaImportGenerator(new MavenRepository(repoDirectory), workspace).processPomFiles();
        System.out.println("Done.");
    }

    private static void usage() {
        System.err.println("Usage: java_import_generator [path/to/m2/repository]");
        System.err.println("");
        System.err.println(
                "If the path to m2 repo is omitted, the one from current WORKSPACE will be used.");
        System.exit(1);
    }

    private final MavenRepository mRepo;
    private final Workspace mWorkspace;

    public JavaImportGenerator(MavenRepository repo, Workspace workspace) {
        mRepo = repo;
        mWorkspace = workspace;
    }

    private void processPomFiles() throws IOException, ArtifactDescriptorException {
        try (Stream<Path> stream = Files.walk(mRepo.getDirectory())) {
            stream.filter(path -> path.toString().endsWith(".pom"))
                    .forEach(
                            pom -> {
                                try {
                                    processPomFile(pom, true);
                                } catch (IOException e) {
                                    throw new UncheckedIOException(e);
                                }
                            });

            System.out.println();
        }
        save();
    }

    /**
     * Processes a pom file generating all the rules needed for this pom.
     *
     * @return the path to a parent pom file if it exists.
     */
    private Path processPomFile(Path pomFile, boolean delete) throws IOException {
        Model pomModel = mRepo.getPomEffectiveModel(pomFile);
        if (pomModel == null) {
            return null;
        }
        Path artifact = null;
        if (SUPPORTED_EXTENSIONS.contains(MavenRepository.getArtifactExtension(pomModel))) {
            artifact = mRepo.getArtifactPath(pomModel);
            if (!Files.exists(artifact)) {
                System.err.println("Missing artifact: " + mRepo.relativize(artifact));
            }
        }

        Path parentPom = null;
        if (pomModel.getParent() != null) {
            parentPom = mRepo.getParentPomPath(pomModel);
        }
        Map<String, Path> exes = mRepo.getExecutables(pomModel);
        generateImportRules(artifact, pomFile, parentPom, delete, exes);
        return parentPom;
    }

    public void generateImportRules(Artifact artifact) throws IOException {
        Path pomFile = mRepo.getPomPath(artifact);
        while (pomFile != null) {
            pomFile = processPomFile(pomFile, false);
        }
    }

    private void generateImportRules(
            @Nullable Path artifact,
            @Nonnull Path pomFile,
            @Nullable Path parentPath,
            boolean delete,
            @Nonnull Map<String, Path> exes)
            throws IOException {
        Path rel = mWorkspace.getDirectory().toPath().relativize(mRepo.getDirectory());
        Package pkg = mWorkspace.findPackage(rel.toString());

        String[] parts = mRepo.getDirectory().relativize(pomFile.getParent()).toString().split("/");
        String name = String.join(".", parts);

        if (artifact != null && Files.exists(artifact)) {
            CallExpression rule;
            Map<String, Object> args = new HashMap<String, Object>();
            Path repoPath = pkg.getPackageDir().toPath().relativize(pomFile.getParent());
            Path relPath = pkg.getPackageDir().toPath().relativize(artifact);
            args.put("visibility", ListExpression.build("//visibility:public"));
            if (artifact.toString().endsWith(".jar")) {
                args.put("name", name);
                args.put("jars", ListExpression.build(ImmutableList.of(relPath.toString()), true));
                args.put("pom", ":" + name + POM_RULE_SUFFIX);
                args.put("repo_path", repoPath.toString());
                rule = CallExpression.build("maven_java_import", args);
            } else if (artifact.toString().endsWith(".aar")) {
                args.put("name", name + AAR_RULE_SUFFIX);
                args.put("aar", relPath.toString());
                args.put("pom", ":" + name + POM_RULE_SUFFIX);
                rule = CallExpression.build("maven_aar", args);
            } else if (artifact.toString().endsWith(".apk")) {
                args.put("name", name + APK_RULE_SUFFIX);
                args.put("aar", relPath.toString());
                args.put("pom", ":" + name + POM_RULE_SUFFIX);
                rule = CallExpression.build("maven_aar", args);
                rule.addPreComment(Token.ident(
                        "# The rule is called maven_aar but works for APKs as well.\n"));
            } else {
                throw new IllegalArgumentException(
                        "Don't know how to generate import for " + artifact);
            }
            addRule(pkg, rule, delete);
        }
        Path relPath = pkg.getPackageDir().toPath().relativize(pomFile);
        CallExpression rule = CallExpression.build("maven_pom", ImmutableMap.of(
                "name", name + POM_RULE_SUFFIX,
                "source", relPath.toString(),
                "visibility", ListExpression.build(ImmutableList.of("//visibility:public"), true)));
        if (parentPath != null) {
            String[] parts2 = mRepo.getDirectory().relativize(parentPath.getParent()).toString().split("/");
            String parentName = String.join(".", parts2);
            rule.setArgument("parent", ":" + parentName + POM_RULE_SUFFIX);
        }
        addRule(pkg, rule, delete);

        boolean exist = true;
        Map<String, Expression> dict = new TreeMap<>();
        for (Map.Entry<String, Path> exe : exes.entrySet()) {
            exist = exist && Files.exists(exe.getValue());
            relPath = pkg.getPackageDir().toPath().relativize(exe.getValue());
            dict.put("//prebuilts/tools/common/m2:" + exe.getKey(),
                     ListExpression.build(ImmutableList.of(relPath.toString()), true));
        }
        if (exist) {
            rule = CallExpression.build("filegroup", ImmutableMap.of(
                    "name", name + EXE_RULE_SUFFIX,
                    "srcs", new CallExpression(null, Token.ident("select"),
                            ImmutableList.of(new Argument(DictExpression.build(dict))),
                            Token.NONE),
                    "visibility", ListExpression.build(ImmutableList.of("//visibility:public"), true)));
            addRule(pkg, rule, delete);
        }
    }

    public void save() throws IOException {
        boolean dryRun = false;
        Path rel = mWorkspace.getDirectory().toPath().relativize(mRepo.getDirectory());
        Package pkg = mWorkspace.findPackage(rel.toString());
        File tmp = File.createTempFile("BUILD", "test");
        try (FileOutputStream fileOutputStream = new FileOutputStream(tmp);
             OutputStreamWriter outputStreamWriter =
                     new OutputStreamWriter(fileOutputStream, StandardCharsets.UTF_8);
             PrintWriter writer = new PrintWriter(outputStreamWriter)) {
            pkg.getBuildFile().write(writer);
        }
        if (!dryRun) {
            Files.copy(
                    tmp.toPath(),
                    pkg.findBuildFile().toPath(),
                    StandardCopyOption.REPLACE_EXISTING);
            tmp.delete();
        } else {
            System.out.println("diff " + pkg.findBuildFile().getAbsolutePath() + " " + tmp.getAbsolutePath());
        }
    }

    private void addRule(Package pkg, CallExpression rule, boolean delete)
            throws IOException {
        CallStatement call = new CallStatement(rule);
        String name = rule.getNamedArgument("name").getExpression().getLiteral();
        List<Statement> statements = pkg.getBuildFile().getStatements();
        ListIterator<Statement> it = statements.listIterator();
        boolean found = false;
        while (it.hasNext()) {
            Statement statement = it.next();
            if (!(statement instanceof CallStatement)) {
                continue;
            }
            Expression arg = ((CallStatement) statement).getCall().getArgument("name");
            if (arg != null) {
                if (arg.getLiteral().equals(name)) {
                    found = true;
                    if (delete) {
                        it.set(call);
                    }
                    break;
                }
            }
        }
        if (!found) {
            statements.add(call);
        }
    }
}
